digraph {
graph [
label = "system.nim & collections/*
filtering for string";
rankdir=LR;
];
node[color=coral, style=filled, label="string" ] N0;
node[color=coral, style=filled, label="bool" ] N1;
N0 -> N1 [color="", label="`==` (string)" ];
N0 -> N1 [color="", label="`<=` (string)" ];
N0 -> N1 [color="", label="`<` (string)" ];
node[color=coral, style=filled, label="int" ] N2;
N0 -> N2 [color="", label="len" ];
N0 -> N2 [color="", label="cmp(string)" ];
node[color=coral, style=filled, label="Natural" ] N3;
N3 -> N0 [color="", label="newString" ];
N3 -> N0 [color="", label="newStringOfCap" ];
N0 -> N0 [color="", label="`&` (char)" ];
node[color=coral, style=filled, label="char" ] N4;
N4 -> N0 [color="", label="`&` (char)" ];
N0 -> N0 [color="", label="`&` (string)" ];
N4 -> N0 [color="", label="`&` (string)" ];
N0 -> N1 [color="", label="compileOption" ];
N0 -> N1 [color="", label="compileOption(string)" ];
node[color=coral, style=filled, label="T" ] N5;
N5 -> N0 [color="", label="repr" ];
N0 -> N0 [color="", label="copy(first = 0)" ];
N0 -> N0 [color="", label="copy(int, int)" ];
N0 -> N0 [color="", label="substr(first = 0)" ];
N0 -> N0 [color="", label="substr(int, int)" ];
N2 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="int64" ] N6;
N6 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="uint64" ] N7;
N7 -> N0 [color="", label="`$` " ];
node[color=coral, style=filled, label="float" ] N8;
N8 -> N0 [color="", label="`$` " ];
N1 -> N0 [color="", label="`$` " ];
N4 -> N0 [color="", label="`$` " ];
node[color=coral, style=filled, label="cstring" ] N9;
N9 -> N0 [color="", label="`$` " ];
N0 -> N0 [color="", label="`$` " ];
node[color=coral, style=filled, label="TEnum" ] N10;
N10 -> N0 [color="", label="`$` " ];
N0 -> N2 [color="", label="getRefcount" ];
node[color=coral, style=filled, label="tuple[key: int, val: char]" ] N11;
N0 -> N11 [color="green", label="pairs" ];
N0 -> N1 [color="", label="isNil" ];
N5 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="set[T]" ] N12;
N12 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="seq[T]" ] N13;
N13 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="array[IDX, T]" ] N14;
N14 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="" ] N15;
N15 -> N0 [color="", label="GC_getStatistics" ];
node[color=coral, style=filled, label="File" ] N16;
N0 -> N16 [color="", label="open(mode: FileMode = fmRead, bufSize: int = -1)" ];
node[color=coral, style=filled, label="TaintedString" ] N17;
N0 -> N17 [color="", label="readFile" ];
N15 -> N0 [color="", label="getStackTrace" ];
node[color=coral, style=filled, label="ref Exception" ] N18;
N18 -> N0 [color="", label="getStackTrace" ];
N0 -> N17 [color="green", label="lines" ];
N15 -> N0 [color="", label="getCurrentExceptionMsg" ];
N0 -> N15 [color="", label="quit(errorcode := QuitFailure)" ];
N0 -> N0 [color="", label="`[]`(Slice[int])" ];
N0 -> N0 [color="", label="slurp" ];
N0 -> N0 [color="", label="staticRead" ];
N0 -> N0 [color="", label="gorge(input = \"\")" ];
N0 -> N0 [color="", label="staticExec(input = \"\")" ];
N5 -> N0 [color="", label="astToStr" ];
N0 -> N15 [color="", label="raiseAssert" ];
N0 -> N15 [color="", label="failedAssertImpl" ];
N0 -> N4 [color="green", label="items" ];
N0 -> N2 [color="", label="xlen" ];
node[color=coral, style=filled, label="CritBitTree[T]" ] N19;
N19 -> N0 [color="green", label="keys" ];
N19 -> N0 [color="green", label="items" ];
N19 -> N0 [color="green", label="itemsWithPrefix(string)" ];
N19 -> N0 [color="green", label="keysWithPrefix(string)" ];
N19 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="IntSet" ] N20;
N20 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="SinglyLinkedList[T]" ] N21;
N21 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="DoublyLinkedList[T]" ] N22;
N22 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="SinglyLinkedRing[T]" ] N23;
N23 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="DoublyLinkedRing[T]" ] N24;
N24 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="Queue[T]" ] N25;
N25 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="HashSet[A]" ] N26;
N26 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="OrderedSet[A]" ] N27;
N27 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="Table[A, B]" ] N28;
N28 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="TableRef[A, B]" ] N29;
N29 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="OrderedTable[A, B]" ] N30;
N30 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="OrderedTableRef[A, B]" ] N31;
N31 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="CountTable[A]" ] N32;
N32 -> N0 [color="", label="`$`" ];
node[color=coral, style=filled, label="CountTableRef[A]" ] N33;
N33 -> N0 [color="", label="`$`" ];
N0 -> N0 [color="", label="toLower" ];
N0 -> N0 [color="", label="toUpper" ];
N0 -> N0 [color="", label="capitalize" ];
N0 -> N0 [color="", label="normalize" ];
N0 -> N2 [color="", label="cmpIgnoreCase(string)" ];
N0 -> N2 [color="", label="cmpIgnoreStyle(string)" ];
N0 -> N0 [color="", label="strip(leading = true, trailing = true, chars: set[char] = Whitespace)" ];
N4 -> N0 [color="", label="toOctal" ];
N0 -> N0 [color="green", label="split(seps: set[char] = Whitespace)" ];
N0 -> N0 [color="green", label="split(char)" ];
N0 -> N0 [color="green", label="split(string)" ];
N0 -> N0 [color="green", label="splitLines" ];
node[color=coral, style=filled, label="seq[string]" ] N34;
N0 -> N34 [color="", label="splitLines" ];
N0 -> N2 [color="", label="countLines" ];
N0 -> N34 [color="", label="split(seps: set[char] = Whitespace)" ];
N0 -> N34 [color="", label="split(char)" ];
N0 -> N34 [color="", label="split(string)" ];
node[color=coral, style=filled, label="BiggestInt" ] N35;
N35 -> N0 [color="", label="toHex(Positive)" ];
N2 -> N0 [color="", label="intToStr(minchars: Positive = 1)" ];
N0 -> N2 [color="", label="parseInt" ];
N0 -> N35 [color="", label="parseBiggestInt" ];
N0 -> N8 [color="", label="parseFloat" ];
N0 -> N2 [color="", label="parseHexInt" ];
N0 -> N1 [color="", label="parseBool" ];
N0 -> N5 [color="", label="parseEnum" ];
N0 -> N5 [color="", label="parseEnum(T)" ];
N4 -> N0 [color="", label="repeat(Natural)" ];
N0 -> N0 [color="", label="repeat(Natural)" ];
N3 -> N0 [color="blue", label="spaces" ];
N3 -> N0 [color="", label="repeatChar(c: char = ' ')" ];
N3 -> N0 [color="", label="repeatStr(string)" ];
N0 -> N0 [color="", label="align(Natural, padding = ' ')" ];
node[color=coral, style=filled, label="tuple[" ] N36;
N0 -> N36 [color="green", label="tokenize(seps: set[char] = Whitespace)" ];
N0 -> N0 [color="", label="unindent(eatAllIndent = false)" ];
N0 -> N1 [color="", label="startsWith(string)" ];
N0 -> N1 [color="", label="endsWith(string)" ];
N0 -> N1 [color="", label="continuesWith(string, Natural)" ];
N0 -> N1 [color="", label="allCharsInSet(set[char])" ];
N0 -> N2 [color="", label="abbrev(openArray[string])" ];
node[color=coral, style=filled, label="openArray[string]" ] N37;
N37 -> N0 [color="", label="join(string)" ];
N37 -> N0 [color="", label="join" ];
N0 -> N2 [color="", label="find(string, start: Natural = 0)" ];
N0 -> N2 [color="", label="find(char, start: Natural = 0)" ];
N0 -> N2 [color="", label="find(set[char], start: Natural = 0)" ];
N0 -> N2 [color="", label="rfind(string, start: int = -1)" ];
N0 -> N2 [color="", label="rfind(char, start: int = -1)" ];
N0 -> N2 [color="", label="count(string, overlapping: bool = false)" ];
N0 -> N2 [color="", label="count(char)" ];
N0 -> N2 [color="", label="count(set[char])" ];
N0 -> N0 [color="", label="quoteIfContainsWhite" ];
N0 -> N1 [color="", label="contains(char)" ];
N0 -> N1 [color="", label="contains(string)" ];
N0 -> N1 [color="", label="contains(set[char])" ];
N0 -> N0 [color="", label="replace(string, by = \"\")" ];
N0 -> N0 [color="", label="replace(char, char)" ];
N0 -> N0 [color="", label="replaceWord(string, by = \"\")" ];
N0 -> N2 [color="", label="parseOctInt" ];
N35 -> N0 [color="", label="toOct(Positive)" ];
N35 -> N0 [color="", label="toBin(Positive)" ];
N0 -> N0 [color="", label="insertSep(sep = '_', digits = 3)" ];
N0 -> N0 [color="", label="escape(prefix = \"\\\"\", suffix = \"\\\"\")" ];
N0 -> N0 [color="", label="unescape(prefix = \"\\\"\", suffix = \"\\\"\")" ];
N0 -> N1 [color="", label="validIdentifier" ];
N0 -> N2 [color="", label="editDistance(string)" ];
node[color=coral, style=filled, label="BiggestFloat" ] N38;
N38 -> N0 [color="", label="formatBiggestFloat(format: FloatFormatMode = ffDefault, precision: range[0..32] = 16)" ];
N8 -> N0 [color="", label="formatFloat(format: FloatFormatMode = ffDefault, precision: range[0..32] = 16)" ];
N35 -> N0 [color="", label="formatSize(decimalSep = '.')" ];
N0 -> N0 [color="", label="`%` (openArray[string])" ];
N0 -> N0 [color="", label="`%` (string)" ];
N0 -> N0 [color="", label="format(varargs[string, `$`])" ];
}
